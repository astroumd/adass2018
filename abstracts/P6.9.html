<html> <body>
Prev: <A HREF=P6.8.html>P6.8</A> Next: <A HREF=P6.10.html>P6.10</A> <br><br>
<b>P6.9: Paxson, Charles</b>
<br>
Charles Paxson (Smithsonian Astrophysical Observatory) <br>   <br>   <br>   <br>   <br>  <br><br>
<br>
<b>Theme:</b>  DevOps Practices in Astronomy Software
<br>
<b>Title:</b> <i>Transforming Science Code into Maintainable Software, Insights into the G-CLEF Exposure Time Calculator</i>
<br><br>
We explore a common workflow in research institutions where science code is transformed into robust, maintainable, and expandable code. The case study presented is the Exposure Time Calculator (ETC) for the Giant Magellan Telescope Consortium Large Earth Finder (G-CLEF) spectrometer.  We describe the process we took to develop requirements documentation and a web application from science code.  The ETC provides a rich set of features to help the scientists estimate the performance of the instrument including: the computation of exposure time, SNR, and precision radial velocity, GUI text results, downloadable FITS standard compliant summary of results, and graphical displays.  We highlight the importance of a requirements document for information exchange between scientist and engineer, where principles and assumptions can be collaboratively understood and solidified.  As the document matures, scientists may use it to specify new requirements.  We discuss the importance of making physical interpretations of the code, of understanding and ultimately cleaning of science code magic numbers, and of comprehending the overall flow.   This detailed analysis is important since requirements morph as the project progresses.  Therefore, a modular design, especially segmenting calibration tables from source code, allow hardware engineering data upgrades without affecting software code.  Science code need not be efficient in processing speed, and illuminating black boxes allow potential speed improvements.  The software implementation is verified by comparison with hand calculations by scientists and standard data sets (in our case, flux comparisons to stellar standards of known type), and implementing best practices such as unit tests.  We analyze this process for our own purposes as well as sharing this process to assist future software engineers.
</body> </html>
